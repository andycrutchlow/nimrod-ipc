nimrod-ipc
==========

A simple API for interprocess communication for java using ZeroMQ.

ZeroMQ supports many advanced messaging scenarios. This API covers two major use-cases which I find useful when developing enterprise/distributed applications whilst requiring minimal configuration and code to use these features :

1) Remote method invocation : A thread in running in one jvm (client process) can call any exposed method in any exposed class running in another jvm (server process) passing to it any required arguments for the target method. The calling application thread is blocked until a response object is returned by the called method or an exception is thrown or, if a timeout is supplied, the timeout expires. Any number of calling threads in the client jvm can be in progress whilst the server jvm is servicing any number of client calls. The calls are multiplexed from the client process over one pre-existing transport connection to the server and dispatched to and handled by descrete worker threads in server to maximise concurrency. The size of thread pools are configurable. The response is not dictated by FIFO to the server but rather how long the specific call takes to complete in the server. A jvm process can be a client to any number of server processes or a server to any number of different clients processes or a mixture of both. A server process can make services (methods) available on one or more transports. Applicable ZeroMQ Transports covered are "ipc" for processes co-located on same physical server or "tcp" if processes are running on different physical servers. Leveraging ZeroMQ features it does not matter the order that the processes are instantiated. A client process will connect to a server process when the server process becomes available. This might be immediately if the server process is already running or later if the server process is yet to start. Appropriate exceptions will be thrown during time that server process is unavailable. Whilst the underlying ZeroMQ messaging is asynchronous the API RMI calls are synchronous in their nature because thats how I have contrived it but that said they can behave in an asynchronous manner if desired. If the target method running in the client process side delegates the activity to another application thread and returns immediately. Applying this usage is effectively implementing a form of gauranteed message delivery. 

2) Publish/Subscribe : From a publisher instance any thread can simply and directly publish on any subject a message payload containing any serializable object. A subscriber instance can dynamically register (or unregister) any number of callbacks on any subject and directly receive the deserialzed object. On the subscriber side messages for the same subject will be dispatched to a temporarily dedicated thread for that subject via a queue executor therefore maintaining the strict sequence the messages arrive in. Other messages arriving at the same time but for different subjects will be dispatched to corresponding threads as appropriate according to same rules but constrained by threadpool configuration. Two types of queue executors are available. The sequential executor will receive and process all messages received for a given subject. The conflating executor will receive and process the latest message received for a given subject skipping any intermediate ones that arrived during the processing of the current message skipping to the latest on completion. One-to-many and many-to-one patterns are supported.

Serialzers are pluggable and the type to use for an RMI call or message publish/subscribe can optionally be supplied in the API calls.

A further optional extension or mode is available. By running a supplied agent process two extra functions become available :

1) Latest value re-publish on initial subscription. So when a subject is initially subscribed to by a subscriber process the publisher of that subject will re-publish its most recent value so the subscriber process immediately sees the current value rather than having to wait for the next change.

2) Any start or stop of either a RMI service (server or client side) or a PubSub service (publisher or subscriber side) will be communicated to all other processes running the API which are configured to connect to the agent and have registered callbacks expressing an interest in a particular services' start or stop event.

Prerequisites :
Native libraries for ZeroMQ built/installed and available to jvm via java.library.path. Similarly, native libraries for java bindings for ZeroMQ for the target deployment environment. Excellent documentation/instructions along with downloads are available at http://zeromq.org/intro:get-the-software and http://zeromq.org/bindings:java.
I have developed/tested against Stable Release 4.0.4.
In theory jeromq https://github.com/zeromq/jeromq should work also as an alternative to the native version, but I have yet to test to confirm.

An explanation of the name :
I am a freelance software engineer. Nimrod Technology Services is the name of my incorporated company in Canada. Amongst other things Nimrod is the name of an aircraft my father flew in whilst serving in the RAF. Nimrod is also term coined by bugs bunny from loony tunes and has come to mean stupid or simple-minded...and I like that association and irony in that I am striving to keep api's as simple as possible in their usage, hiding away the complexity. Nimrod is also the name of a programming language and appologies to those who have arrived here thinking that this is a library or extension to the actual Nimrod language.
